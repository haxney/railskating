These are some things to keep in mind, as well as planned features.

* Events can span sections
  Though it doesn't happen in amateur competitions, it is possible to have
  10-dance events in which all of Standard and Latin are danced in a single
  event. This means I should not assume that each event belongs to only one
  section.

  Currently, this is not a problem, since the only link between the =Event= and
  =Section= models is through the =SubEvent= and =Dance= models, so this is not
  currently a problem.
* Placements for unlinked dances can be fractional
  If two couples tie in a single dance, then technically they are both awarded a
  fractional place, such as "4.5th place". Currently, =SubPlacement= models
  store the rank as an integer. This could be changed to a rational or decimal.
  Probably not a float, since precision issues would be majorly annoying.
* A single user can change teams
  Currently, the =Team= is stored directly on the =User= model, but it would be
  more accurate if teams were stored per-competition. This would involve
  creating a model which was just a three-way join table between the =User=,
  =Competition=, and =Team= models.
* TBA and "unknown" handling
  Should there be a single, global "TBA" user or should each TBA be treated
  separately? In a strict validation mode, it might cause problems if the "same"
  user appeared multiple times in the same event, in different couples. A "User
  type" column could be added which is either "normal", "TBA" or "Unknown".
  Single-table inheritance could be used for these cases.
* =:finder_sql= is deprecated
  I use it extensively for associations, but it is going away in Rails 4.1.
  Looking around for a while didn't reveal a solution, so if Railskating is ever
  upgraded to Rails 4.1, this would need to be handled somehow.
* Use as an alternative frontend to existing results sites
  Even before the site is able to handle a complete competition, it could serve
  as a frontend to an existing result site like [[http://www.dance.zsconcepts.com/][ZSConcepts]]. If the scraping
  process were automated, it could have results up immediately after they are
  published on the other sites.

  Oh god, [[http://ballroom-media.mit.edu/archive/Competitions/MIT13/][MIT]]'s results listing page is even worse than ZSConcepts'! Each event
  is just one giant table, with the rounds separated by rows with the =bgcolor=
  set to dark gray!
* Visual elements on results pages
  Here are some ideas about how to make the results pages more useful for users.
** Zebra-striped tables
   This would probably help make the large results pages easier to digest. A
   quick look at the (very) small number of studies about it says that zebra
   striping doesn't buy you that much, and some people really didn't like
   triple-striped tables. There's some playing around to be done there, for
   sure.
** Select-to-highlight rows
   Have an option to click on a row to highlight it. This would be an even
   bigger help, but not as dramatic as...
** Live-filtering rows
   Typically, the person looking at the results page only cares about how they
   or their teammates did. There could be a box at the top of the page which let
   the user enter a set of couple numbers and then hide all rows except for
   those with the specified couples. It could also select by team name.
** User summary page
   A page could be generated to show a total breakdown of how a single user did
   in the whole competition. It could display all of their marks in all of their
   dances.
** Judge ranking information
   A page could show which judges preferred a particular user or couple, and
   even show how that changed across different competitions.
** Couple comparisons
   A page could show how two couples or users match up against each other over
   the course of multiple competitions.
** Team information tracking
   Some kind of display for how teams tend to perform at competitions.
* User eligibility tracker
  If all or most competitions were imported or run through Railskating, it would
  be easy to see whether a user was dancing down after having pointed out of a
  certain level. This could obviously be defeated by creating new =User= models
  when registering for each competition, but there are probably ways to counter
  that. If multiple =User= models shared the same (or similar) name, they could
  be listed together. Something like "User 43 has 1 point in Silver Smooth.
  Users 13, 78, and 92 have the same name, combining them all, they have 9
  points in Silver Smooth." This way, if two different people really do have the
  same, name, it would be easy to see, but one could also see if the same user
  just registered under different accounts.
* Callback information during a competition
** Projector view
  Railskating could be used to manage a competition and provide a more appealing
  display for callback information during a competition.
** User- or team-specific display
   It could be on a live website, so contestants could check their own status on
   their phones or computers. It could have a "team view" feature which would
   list, for a particular team, all of the couples who were still in the
   competition. A user would enter a couple or team and it would list all of the
   events in which they were still in the running. This could prevent crowding
   around the projector or problems when the projector malfunctions as well as
   being able to display only the events in which a particular user is
   interested.

   A common issue is that, while the system might know which couples got called
   back to the next round, the space on the projector is so limited that it can
   only show a small number of events at a time. Being able to select which
   events to display would solve this issue.
* Judge mark card scanning
  This is a long way away, but the system could be hooked up to a scanner and an
  OCR program to automatically import the judges marks. It would most likely
  require human verification, but could save some poor soul a lot of numpad
  entry. This would likely require a desktop application of some kind to
  streamline the process of uploading scanned cards. Combine this with an
  automatically-feeding scanner, and scrutineering a competition could become
  significantly less labor-intensive.
* DJ integration
  This is more fantasy-land stuff, but Railskating could make use of the HTML5
  audio API to handle playing the music for dances. It could also list the names
  of the songs used in the results page, with affiliate links to music stores as
  a way of making some money for the site.
